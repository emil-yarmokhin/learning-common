Бинарный поиск - алгоритм позволяющий найти индекс элемента в отсортированном массиве.
Принцип:
1. Поиск среднего элемента и его соответствие индексу;
2. Определение, в какой из сторон находится нужный элемент от среднего;
3. Повторение пункта 1 и 2;

Смысл:
1. Объявление главных переменных, из которых что-то будет на выходе;
2. Объявить, что с ними должно быть на выходе.

далее

3. Объявление вспомогательных переменных и методов их применения (в методе должно быть прописано, что это напрямую относится к тому, что в шапке.
4. Вывод.

 public static void main(String[] args) {
        int [] sortedArray = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100};
        int key = 86;
        int position = binarySearch(sortedArray, key);
        System.out.println(key + " расположен на " + position + " месте в ряде числ.");
    }
    static int binarySearch (int [] array, int key) {
        int left = 0;
        int right = array.length - 1;

        while (right >= left) {
            int middle = (right + left)/2;
            if (array[middle] == key) {
                System.out.println("Key found.");
                return middle;
            }
            if (array[middle] > key) {
                System.out.println("Cut right half.");
                right = middle - 1;
            }
            if (array[middle] < key) {
                System.out.println("Cut left half.");
                left = middle + 1;
            }
        }
        return -1;
    }