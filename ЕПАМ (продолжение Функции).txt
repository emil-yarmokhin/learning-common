FUNCTIONS
Функции - это некая сущность, хранящая алгоритм и предоставляющая возможность удобный интерфейс для передачи и возврата значения.
Как выглядит функция:
1. Тип данных, которая она возвращает;
2. Имя функции;
3. Тип данных, которые она принимает.
double getAverageValue(int[] array)
1. double - показывает среднее значение в массиве intов

void - функция ничего не возвращает, мы ничего не можем из неё получить. Всё печатается в консоли и оттуда ничего взять нельзя.

public class Main {

    public static void main(String[] args) {
        int[] array = {28, 24, 22, 18};
        printArrayToConsole(array);
        double sum = 0.0; // объявление переменной sum типа double со знач. 0.0
        sum = sumDouble(1.0, 2.0); // вызов суммы, который вызывает метод сумм
        System.out.println(sum); //печать sum
    }

    static double sumDouble(double a, double b) { // ф, возвр. сумму 2 чисел
        double sum = a + b; // объявление дабла;
        return sum; // ключ. слово "вернуть"
    }

    static void printArrayToConsole(int[] printArray) {
        for (int i = 0; i < printArray.length; i++) {
            System.out.print(printArray[i] + " ");
        }
    }
}


АЛГОРИТМЫ
BIG O (сложность алгоритмов)
big o очень часто, практически всегда зависит от того, сколько элементов на входе.
Но некоторые алгоритмы не зависят от входных данных. Например, поиск элементов по значению индекса O(1) - константное время займёт получения элемента под опр. номером.

Уже чуть больше зависит от входных данных - логорифмическая (O(log n)): при увеличении входных данных, у нас не сильно будет увеличиваться кол-во шагов, которые необходимо выполнить компьютеру.

O(n) - прямо пропорционально кол-ву элементов. 100 элементов - 100 проверок.

Логоритм сортировок (O(n^2)). bubble sort: для сортировки 10 элементов нужно 100 операций, для 100 - 10000.

Quicksort (O(n log n)) - имеет преимущества перед (O(n^2)).

Bogosort O((n+1)!) "глупая сортировка" - фигурирует чаще в книгах по математике, чем на практике. Перемешивание элементов в случайном порядке и проверка, отсортировались ли они, или нет. Это больше похоже на бросок игральных карт в воздух.

SEARCHING IN ARRAY
int [] array = {20, 91, 64, 75, 19, 26, 48, 55, 89}
Чтобы найти min и max, нужно пройтись по всему массиву

    public static void main(String[] args) {
        int[] array10 = {45, 71, 30, 62, 83, 69, 86, 41, 91, 90};
        int[] array100 = {72, 29, 82, 10, 88, 74, 86, 14, 40, 83, 98, 80, 7, 67, 26, 64, 62, 52, 61, 90, 39, 66, 6, 41, 50, 97, 34, 65, 77, 49, 73, 55, 58, 28, 43, 79, 76, 47, 32, 95, 5, 23, 56, 94, 22, 99, 2, 96, 35, 37, 84, 9, 21, 63, 78, 25, 91, 4, 57, 3, 75, 27, 20, 51, 19, 59, 38, 30, 46, 54, 1, 93, 13, 8, 31, 45, 18, 100, 17, 33, 53, 68, 81, 48, 71, 89, 70, 44, 16, 60, 15, 36, 85, 69, 24, 87, 11, 92, 42, 12};
        printarray(array100);
        }
        static void printarray (int [] array) {
        int max = array[0];
        int ind = 0;
        int rep = 0;
        int con = 0;
            for (int i = 0; i < array.length; i++) {
                if (array[i] > max) {
                    max = array[i];
                    ind = i;
                    rep++;
                }
                con++;
            }
            System.out.println("Максимальнео число: " + max + ". Операция завершена.");
            System.out.println("Максимальный индекс: " + ind + ". Операция завершена.");
            System.out.println("Количество замен: " + rep + ". Операция завершена.");
            System.out.println("Количество циклов: " + con + ". Операция завершена.");
        }

